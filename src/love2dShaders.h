//
// Created by Callum Todd on 2020/04/13.
//

#include <string>

std::string defaultVertexShaderCode =
    "#version 330 core\n"
    "#define VERTEX VERTEX\n"
    "\n"
    "\n"
    "\n"
    "#if !defined(GL_ES) && __VERSION__ < 140\n"
    "#define lowp\n"
    "	#define mediump\n"
    "	#define highp\n"
    "#endif\n"
    "#if defined(VERTEX) || __VERSION__ > 100 || defined(GL_FRAGMENT_PRECISION_HIGH)\n"
    "#define LOVE_HIGHP_OR_MEDIUMP highp\n"
    "#else\n"
    "#define LOVE_HIGHP_OR_MEDIUMP mediump\n"
    "#endif\n"
    "#define number float\n"
    "#define Image sampler2D\n"
    "#define ArrayImage sampler2DArray\n"
    "#define CubeImage samplerCube\n"
    "#define VolumeImage sampler3D\n"
    "#if __VERSION__ >= 300 && !defined(LOVE_GLSL1_ON_GLSL3)\n"
    "#define DepthImage sampler2DShadow\n"
    "	#define DepthArrayImage sampler2DArrayShadow\n"
    "	#define DepthCubeImage samplerCubeShadow\n"
    "#endif\n"
    "#define extern uniform\n"
    "#ifdef GL_EXT_texture_array\n"
    "#extension GL_EXT_texture_array : enable\n"
    "#endif\n"
    "#ifdef GL_OES_texture_3D\n"
    "#extension GL_OES_texture_3D : enable\n"
    "#endif\n"
    "#ifdef GL_OES_standard_derivatives\n"
    "#extension GL_OES_standard_derivatives : enable\n"
    "#endif\n"
    "\n"
    "#define love_Position gl_Position\n"
    "\n"
    "#if __VERSION__ >= 130\n"
    "#define attribute in\n"
    "	#define varying out\n"
    "	#ifndef LOVE_GLSL1_ON_GLSL3\n"
    "		#define love_VertexID gl_VertexID\n"
    "		#define love_InstanceID gl_InstanceID\n"
    "	#endif\n"
    "#endif\n"
    "\n"
    "#ifdef GL_ES\n"
    "    uniform mediump float love_PointSize;\n"
    "#endif\n"
    "// According to the GLSL ES 1.0 spec, uniform precision must match between stages,\n"
    "// but we can't guarantee that highp is always supported in fragment shaders...\n"
    "// We *really* don't want to use mediump for these in vertex shaders though.\n"
    "    uniform LOVE_HIGHP_OR_MEDIUMP mat4 ViewSpaceFromLocal;\n"
    "uniform LOVE_HIGHP_OR_MEDIUMP mat4 ClipSpaceFromView;\n"
    "uniform LOVE_HIGHP_OR_MEDIUMP mat4 ClipSpaceFromLocal;\n"
    "uniform LOVE_HIGHP_OR_MEDIUMP mat3 ViewNormalFromLocal;\n"
    "uniform LOVE_HIGHP_OR_MEDIUMP vec4 love_ScreenSize;\n"
    "\n"
    "// Compatibility\n"
    "#define TransformMatrix ViewSpaceFromLocal\n"
    "#define ProjectionMatrix ClipSpaceFromView\n"
    "#define TransformProjectionMatrix ClipSpaceFromLocal\n"
    "#define NormalMatrix ViewNormalFromLocal\n"
    "\n"
    "#ifdef GL_ES\n"
    "#if __VERSION__ >= 300 || defined(GL_EXT_texture_array)\n"
    "		precision lowp sampler2DArray;\n"
    "	#endif\n"
    "	#if __VERSION__ >= 300 || defined(GL_OES_texture_3D)\n"
    "		precision lowp sampler3D;\n"
    "	#endif\n"
    "	#if __VERSION__ >= 300\n"
    "		precision lowp sampler2DShadow;\n"
    "		precision lowp samplerCubeShadow;\n"
    "		precision lowp sampler2DArrayShadow;\n"
    "	#endif\n"
    "#endif\n"
    "\n"
    "#if __VERSION__ >= 130 && !defined(LOVE_GLSL1_ON_GLSL3)\n"
    "#define Texel texture\n"
    "#else\n"
    "#if __VERSION__ >= 130\n"
    "#define texture2D Texel\n"
    "		#define texture3D Texel\n"
    "		#define textureCube Texel\n"
    "		#define texture2DArray Texel\n"
    "		#define love_texture2D texture\n"
    "		#define love_texture3D texture\n"
    "		#define love_textureCube texture\n"
    "		#define love_texture2DArray texture\n"
    "#else\n"
    "#define love_texture2D texture2D\n"
    "#define love_texture3D texture3D\n"
    "#define love_textureCube textureCube\n"
    "#define love_texture2DArray texture2DArray\n"
    "#endif\n"
    "vec4 Texel(sampler2D s, vec2 c) { return love_texture2D(s, c); }\n"
    "vec4 Texel(samplerCube s, vec3 c) { return love_textureCube(s, c); }\n"
    "#if __VERSION__ > 100 || defined(GL_OES_texture_3D)\n"
    "vec4 Texel(sampler3D s, vec3 c) { return love_texture3D(s, c); }\n"
    "#endif\n"
    "#if __VERSION__ >= 130 || defined(GL_EXT_texture_array)\n"
    "vec4 Texel(sampler2DArray s, vec3 c) { return love_texture2DArray(s, c); }\n"
    "#endif\n"
    "#ifdef PIXEL\n"
    "vec4 Texel(sampler2D s, vec2 c, float b) { return love_texture2D(s, c, b); }\n"
    "		vec4 Texel(samplerCube s, vec3 c, float b) { return love_textureCube(s, c, b); }\n"
    "		#if __VERSION__ > 100 || defined(GL_OES_texture_3D)\n"
    "			vec4 Texel(sampler3D s, vec3 c, float b) { return love_texture3D(s, c, b); }\n"
    "		#endif\n"
    "		#if __VERSION__ >= 130 || defined(GL_EXT_texture_array)\n"
    "			vec4 Texel(sampler2DArray s, vec3 c, float b) { return love_texture2DArray(s, c, b); }\n"
    "		#endif\n"
    "#endif\n"
    "#define texture love_texture\n"
    "#endif\n"
    "\n"
    "float gammaToLinearPrecise(float c) {\n"
    "  return c <= 0.04045 ? c / 12.92 : pow((c + 0.055) / 1.055, 2.4);\n"
    "}\n"
    "vec3 gammaToLinearPrecise(vec3 c) {\n"
    "  bvec3 leq = lessThanEqual(c, vec3(0.04045));\n"
    "  c.r = leq.r ? c.r / 12.92 : pow((c.r + 0.055) / 1.055, 2.4);\n"
    "  c.g = leq.g ? c.g / 12.92 : pow((c.g + 0.055) / 1.055, 2.4);\n"
    "  c.b = leq.b ? c.b / 12.92 : pow((c.b + 0.055) / 1.055, 2.4);\n"
    "  return c;\n"
    "}\n"
    "vec4 gammaToLinearPrecise(vec4 c) { return vec4(gammaToLinearPrecise(c.rgb), c.a); }\n"
    "float linearToGammaPrecise(float c) {\n"
    "  return c < 0.0031308 ? c * 12.92 : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n"
    "}\n"
    "vec3 linearToGammaPrecise(vec3 c) {\n"
    "  bvec3 lt = lessThanEqual(c, vec3(0.0031308));\n"
    "  c.r = lt.r ? c.r * 12.92 : 1.055 * pow(c.r, 1.0 / 2.4) - 0.055;\n"
    "  c.g = lt.g ? c.g * 12.92 : 1.055 * pow(c.g, 1.0 / 2.4) - 0.055;\n"
    "  c.b = lt.b ? c.b * 12.92 : 1.055 * pow(c.b, 1.0 / 2.4) - 0.055;\n"
    "  return c;\n"
    "}\n"
    "vec4 linearToGammaPrecise(vec4 c) { return vec4(linearToGammaPrecise(c.rgb), c.a); }\n"
    "\n"
    "// http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n"
    "\n"
    "mediump float gammaToLinearFast(mediump float c) { return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878); }\n"
    "mediump vec3 gammaToLinearFast(mediump vec3 c) { return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878); }\n"
    "mediump vec4 gammaToLinearFast(mediump vec4 c) { return vec4(gammaToLinearFast(c.rgb), c.a); }\n"
    "\n"
    "mediump float linearToGammaFast(mediump float c) { return max(1.055 * pow(max(c, 0.0), 0.41666666) - 0.055, 0.0); }\n"
    "mediump vec3 linearToGammaFast(mediump vec3 c) { return max(1.055 * pow(max(c, vec3(0.0)), vec3(0.41666666)) - 0.055, vec3(0.0)); }\n"
    "mediump vec4 linearToGammaFast(mediump vec4 c) { return vec4(linearToGammaFast(c.rgb), c.a); }\n"
    "\n"
    "#define gammaToLinear gammaToLinearFast\n"
    "#define linearToGamma linearToGammaFast\n"
    "\n"
    "#ifdef LOVE_GAMMA_CORRECT\n"
    "#define gammaCorrectColor gammaToLinear\n"
    "	#define unGammaCorrectColor linearToGamma\n"
    "	#define gammaCorrectColorPrecise gammaToLinearPrecise\n"
    "	#define unGammaCorrectColorPrecise linearToGammaPrecise\n"
    "	#define gammaCorrectColorFast gammaToLinearFast\n"
    "	#define unGammaCorrectColorFast linearToGammaFast\n"
    "#else\n"
    "#define gammaCorrectColor\n"
    "#define unGammaCorrectColor\n"
    "#define gammaCorrectColorPrecise\n"
    "#define unGammaCorrectColorPrecise\n"
    "#define gammaCorrectColorFast\n"
    "#define unGammaCorrectColorFast\n"
    "#endif\n"
    "void setPointSize() {\n"
    "#ifdef GL_ES\n"
    "  gl_PointSize = love_PointSize;\n"
    "#endif\n"
    "}\n"
    "attribute vec4 VertexPosition;\n"
    "attribute vec4 VertexTexCoord;\n"
    "attribute vec4 VertexColor;\n"
    "attribute vec4 ConstantColor;\n"
    "\n"
    "varying vec4 VaryingTexCoord;\n"
    "varying vec4 VaryingColor;\n"
    "\n"
    "vec4 position(mat4 clipSpaceFromLocal, vec4 localPosition);\n"
    "\n"
    "void main() {\n"
    "  VaryingTexCoord = VertexTexCoord;\n"
    "  VaryingColor = gammaCorrectColor(VertexColor) * ConstantColor;\n"
    "  setPointSize();\n"
    "  love_Position = position(ClipSpaceFromLocal, VertexPosition);\n"
    "}\n"
    "#line 1\n"
    "vec4 position(mat4 clipSpaceFromLocal, vec4 localPosition) {\n"
    "return clipSpaceFromLocal * localPosition;\n"
    "}\n";

std::string defaultPixelShaderCode =
    "#version 330 core\n"
    "#define PIXEL PIXEL\n"
    "\n"
    "\n"
    "\n"
    "#if !defined(GL_ES) && __VERSION__ < 140\n"
    "#define lowp\n"
    "	#define mediump\n"
    "	#define highp\n"
    "#endif\n"
    "#if defined(VERTEX) || __VERSION__ > 100 || defined(GL_FRAGMENT_PRECISION_HIGH)\n"
    "#define LOVE_HIGHP_OR_MEDIUMP highp\n"
    "#else\n"
    "#define LOVE_HIGHP_OR_MEDIUMP mediump\n"
    "#endif\n"
    "#define number float\n"
    "#define Image sampler2D\n"
    "#define ArrayImage sampler2DArray\n"
    "#define CubeImage samplerCube\n"
    "#define VolumeImage sampler3D\n"
    "#if __VERSION__ >= 300 && !defined(LOVE_GLSL1_ON_GLSL3)\n"
    "#define DepthImage sampler2DShadow\n"
    "	#define DepthArrayImage sampler2DArrayShadow\n"
    "	#define DepthCubeImage samplerCubeShadow\n"
    "#endif\n"
    "#define extern uniform\n"
    "#ifdef GL_EXT_texture_array\n"
    "#extension GL_EXT_texture_array : enable\n"
    "#endif\n"
    "#ifdef GL_OES_texture_3D\n"
    "#extension GL_OES_texture_3D : enable\n"
    "#endif\n"
    "#ifdef GL_OES_standard_derivatives\n"
    "#extension GL_OES_standard_derivatives : enable\n"
    "#endif\n"
    "\n"
    "#ifdef GL_ES\n"
    "    precision mediump float;\n"
    "#endif\n"
    "\n"
    "#define love_MaxCanvases gl_MaxDrawBuffers\n"
    "\n"
    "#if __VERSION__ >= 130\n"
    "#define varying in\n"
    "	// Some drivers seem to make the pixel shader do more work when multiple\n"
    "	// pixel shader outputs are defined, even when only one is actually used.\n"
    "	// TODO: We should use reflection or something instead of this, to determine\n"
    "	// how many outputs are actually used in the shader code.\n"
    "	#ifdef LOVE_MULTI_CANVAS\n"
    "		layout(location = 0) out vec4 love_Canvases[love_MaxCanvases];\n"
    "		#define love_PixelColor love_Canvases[0]\n"
    "	#else\n"
    "		layout(location = 0) out vec4 love_PixelColor;\n"
    "	#endif\n"
    "#else\n"
    "#ifdef LOVE_MULTI_CANVAS\n"
    "#define love_Canvases gl_FragData\n"
    "#endif\n"
    "#define love_PixelColor gl_FragColor\n"
    "#endif\n"
    "\n"
    "// See Shader::updateScreenParams in Shader.cpp.\n"
    "#define love_PixelCoord (vec2(gl_FragCoord.x, (gl_FragCoord.y * love_ScreenSize.z) + love_ScreenSize.w))\n"
    "// According to the GLSL ES 1.0 spec, uniform precision must match between stages,\n"
    "// but we can't guarantee that highp is always supported in fragment shaders...\n"
    "// We *really* don't want to use mediump for these in vertex shaders though.\n"
    "    uniform LOVE_HIGHP_OR_MEDIUMP mat4 ViewSpaceFromLocal;\n"
    "uniform LOVE_HIGHP_OR_MEDIUMP mat4 ClipSpaceFromView;\n"
    "uniform LOVE_HIGHP_OR_MEDIUMP mat4 ClipSpaceFromLocal;\n"
    "uniform LOVE_HIGHP_OR_MEDIUMP mat3 ViewNormalFromLocal;\n"
    "uniform LOVE_HIGHP_OR_MEDIUMP vec4 love_ScreenSize;\n"
    "\n"
    "// Compatibility\n"
    "#define TransformMatrix ViewSpaceFromLocal\n"
    "#define ProjectionMatrix ClipSpaceFromView\n"
    "#define TransformProjectionMatrix ClipSpaceFromLocal\n"
    "#define NormalMatrix ViewNormalFromLocal\n"
    "\n"
    "#ifdef GL_ES\n"
    "#if __VERSION__ >= 300 || defined(GL_EXT_texture_array)\n"
    "		precision lowp sampler2DArray;\n"
    "	#endif\n"
    "	#if __VERSION__ >= 300 || defined(GL_OES_texture_3D)\n"
    "		precision lowp sampler3D;\n"
    "	#endif\n"
    "	#if __VERSION__ >= 300\n"
    "		precision lowp sampler2DShadow;\n"
    "		precision lowp samplerCubeShadow;\n"
    "		precision lowp sampler2DArrayShadow;\n"
    "	#endif\n"
    "#endif\n"
    "\n"
    "#if __VERSION__ >= 130 && !defined(LOVE_GLSL1_ON_GLSL3)\n"
    "#define Texel texture\n"
    "#else\n"
    "#if __VERSION__ >= 130\n"
    "#define texture2D Texel\n"
    "		#define texture3D Texel\n"
    "		#define textureCube Texel\n"
    "		#define texture2DArray Texel\n"
    "		#define love_texture2D texture\n"
    "		#define love_texture3D texture\n"
    "		#define love_textureCube texture\n"
    "		#define love_texture2DArray texture\n"
    "#else\n"
    "#define love_texture2D texture2D\n"
    "#define love_texture3D texture3D\n"
    "#define love_textureCube textureCube\n"
    "#define love_texture2DArray texture2DArray\n"
    "#endif\n"
    "vec4 Texel(sampler2D s, vec2 c) { return love_texture2D(s, c); }\n"
    "vec4 Texel(samplerCube s, vec3 c) { return love_textureCube(s, c); }\n"
    "#if __VERSION__ > 100 || defined(GL_OES_texture_3D)\n"
    "vec4 Texel(sampler3D s, vec3 c) { return love_texture3D(s, c); }\n"
    "#endif\n"
    "#if __VERSION__ >= 130 || defined(GL_EXT_texture_array)\n"
    "vec4 Texel(sampler2DArray s, vec3 c) { return love_texture2DArray(s, c); }\n"
    "#endif\n"
    "#ifdef PIXEL\n"
    "vec4 Texel(sampler2D s, vec2 c, float b) { return love_texture2D(s, c, b); }\n"
    "vec4 Texel(samplerCube s, vec3 c, float b) { return love_textureCube(s, c, b); }\n"
    "#if __VERSION__ > 100 || defined(GL_OES_texture_3D)\n"
    "vec4 Texel(sampler3D s, vec3 c, float b) { return love_texture3D(s, c, b); }\n"
    "#endif\n"
    "#if __VERSION__ >= 130 || defined(GL_EXT_texture_array)\n"
    "vec4 Texel(sampler2DArray s, vec3 c, float b) { return love_texture2DArray(s, c, b); }\n"
    "#endif\n"
    "#endif\n"
    "#define texture love_texture\n"
    "#endif\n"
    "\n"
    "float gammaToLinearPrecise(float c) {\n"
    "  return c <= 0.04045 ? c / 12.92 : pow((c + 0.055) / 1.055, 2.4);\n"
    "}\n"
    "vec3 gammaToLinearPrecise(vec3 c) {\n"
    "  bvec3 leq = lessThanEqual(c, vec3(0.04045));\n"
    "  c.r = leq.r ? c.r / 12.92 : pow((c.r + 0.055) / 1.055, 2.4);\n"
    "  c.g = leq.g ? c.g / 12.92 : pow((c.g + 0.055) / 1.055, 2.4);\n"
    "  c.b = leq.b ? c.b / 12.92 : pow((c.b + 0.055) / 1.055, 2.4);\n"
    "  return c;\n"
    "}\n"
    "vec4 gammaToLinearPrecise(vec4 c) { return vec4(gammaToLinearPrecise(c.rgb), c.a); }\n"
    "float linearToGammaPrecise(float c) {\n"
    "  return c < 0.0031308 ? c * 12.92 : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n"
    "}\n"
    "vec3 linearToGammaPrecise(vec3 c) {\n"
    "  bvec3 lt = lessThanEqual(c, vec3(0.0031308));\n"
    "  c.r = lt.r ? c.r * 12.92 : 1.055 * pow(c.r, 1.0 / 2.4) - 0.055;\n"
    "  c.g = lt.g ? c.g * 12.92 : 1.055 * pow(c.g, 1.0 / 2.4) - 0.055;\n"
    "  c.b = lt.b ? c.b * 12.92 : 1.055 * pow(c.b, 1.0 / 2.4) - 0.055;\n"
    "  return c;\n"
    "}\n"
    "vec4 linearToGammaPrecise(vec4 c) { return vec4(linearToGammaPrecise(c.rgb), c.a); }\n"
    "\n"
    "// http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n"
    "\n"
    "mediump float gammaToLinearFast(mediump float c) { return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878); }\n"
    "mediump vec3 gammaToLinearFast(mediump vec3 c) { return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878); }\n"
    "mediump vec4 gammaToLinearFast(mediump vec4 c) { return vec4(gammaToLinearFast(c.rgb), c.a); }\n"
    "\n"
    "mediump float linearToGammaFast(mediump float c) { return max(1.055 * pow(max(c, 0.0), 0.41666666) - 0.055, 0.0); }\n"
    "mediump vec3 linearToGammaFast(mediump vec3 c) { return max(1.055 * pow(max(c, vec3(0.0)), vec3(0.41666666)) - 0.055, vec3(0.0)); }\n"
    "mediump vec4 linearToGammaFast(mediump vec4 c) { return vec4(linearToGammaFast(c.rgb), c.a); }\n"
    "\n"
    "#define gammaToLinear gammaToLinearFast\n"
    "#define linearToGamma linearToGammaFast\n"
    "\n"
    "#ifdef LOVE_GAMMA_CORRECT\n"
    "#define gammaCorrectColor gammaToLinear\n"
    "	#define unGammaCorrectColor linearToGamma\n"
    "	#define gammaCorrectColorPrecise gammaToLinearPrecise\n"
    "	#define unGammaCorrectColorPrecise linearToGammaPrecise\n"
    "	#define gammaCorrectColorFast gammaToLinearFast\n"
    "	#define unGammaCorrectColorFast linearToGammaFast\n"
    "#else\n"
    "#define gammaCorrectColor\n"
    "#define unGammaCorrectColor\n"
    "#define gammaCorrectColorPrecise\n"
    "#define unGammaCorrectColorPrecise\n"
    "#define gammaCorrectColorFast\n"
    "#define unGammaCorrectColorFast\n"
    "#endif\n"
    "uniform sampler2D love_VideoYChannel;\n"
    "uniform sampler2D love_VideoCbChannel;\n"
    "uniform sampler2D love_VideoCrChannel;\n"
    "\n"
    "vec4 VideoTexel(vec2 texcoords) {\n"
    "  vec3 yuv;\n"
    "  yuv[0] = Texel(love_VideoYChannel, texcoords).r;\n"
    "  yuv[1] = Texel(love_VideoCbChannel, texcoords).r;\n"
    "  yuv[2] = Texel(love_VideoCrChannel, texcoords).r;\n"
    "  yuv += vec3(-0.0627451017, -0.501960814, -0.501960814);\n"
    "\n"
    "  vec4 color;\n"
    "  color.r = dot(yuv, vec3(1.164,  0.000,  1.596));\n"
    "  color.g = dot(yuv, vec3(1.164, -0.391, -0.813));\n"
    "  color.b = dot(yuv, vec3(1.164,  2.018,  0.000));\n"
    "  color.a = 1.0;\n"
    "\n"
    "  return gammaCorrectColor(color);\n"
    "}\n"
    "uniform sampler2D MainTex;\n"
    "varying LOVE_HIGHP_OR_MEDIUMP vec4 VaryingTexCoord;\n"
    "varying mediump vec4 VaryingColor;\n"
    "\n"
    "vec4 effect(vec4 vcolor, Image tex, vec2 texcoord, vec2 pixcoord);\n"
    "\n"
    "void main() {\n"
    "  love_PixelColor = effect(VaryingColor, MainTex, VaryingTexCoord.st, love_PixelCoord);\n"
    "}\n"
    "#line 1\n"
    "vec4 effect(vec4 vcolor, Image tex, vec2 texcoord, vec2 pixcoord) {\n"
    "return Texel(tex, texcoord) * vcolor;\n"
    "}\n";

std::string videoPixelShaderCode =
    "#version 330 core\n"
    "#define PIXEL PIXEL\n"
    "\n"
    "\n"
    "\n"
    "#if !defined(GL_ES) && __VERSION__ < 140\n"
    "#define lowp\n"
    "	#define mediump\n"
    "	#define highp\n"
    "#endif\n"
    "#if defined(VERTEX) || __VERSION__ > 100 || defined(GL_FRAGMENT_PRECISION_HIGH)\n"
    "#define LOVE_HIGHP_OR_MEDIUMP highp\n"
    "#else\n"
    "#define LOVE_HIGHP_OR_MEDIUMP mediump\n"
    "#endif\n"
    "#define number float\n"
    "#define Image sampler2D\n"
    "#define ArrayImage sampler2DArray\n"
    "#define CubeImage samplerCube\n"
    "#define VolumeImage sampler3D\n"
    "#if __VERSION__ >= 300 && !defined(LOVE_GLSL1_ON_GLSL3)\n"
    "#define DepthImage sampler2DShadow\n"
    "	#define DepthArrayImage sampler2DArrayShadow\n"
    "	#define DepthCubeImage samplerCubeShadow\n"
    "#endif\n"
    "#define extern uniform\n"
    "#ifdef GL_EXT_texture_array\n"
    "#extension GL_EXT_texture_array : enable\n"
    "#endif\n"
    "#ifdef GL_OES_texture_3D\n"
    "#extension GL_OES_texture_3D : enable\n"
    "#endif\n"
    "#ifdef GL_OES_standard_derivatives\n"
    "#extension GL_OES_standard_derivatives : enable\n"
    "#endif\n"
    "\n"
    "#ifdef GL_ES\n"
    "    precision mediump float;\n"
    "#endif\n"
    "\n"
    "#define love_MaxCanvases gl_MaxDrawBuffers\n"
    "\n"
    "#if __VERSION__ >= 130\n"
    "#define varying in\n"
    "	// Some drivers seem to make the pixel shader do more work when multiple\n"
    "	// pixel shader outputs are defined, even when only one is actually used.\n"
    "	// TODO: We should use reflection or something instead of this, to determine\n"
    "	// how many outputs are actually used in the shader code.\n"
    "	#ifdef LOVE_MULTI_CANVAS\n"
    "		layout(location = 0) out vec4 love_Canvases[love_MaxCanvases];\n"
    "		#define love_PixelColor love_Canvases[0]\n"
    "	#else\n"
    "		layout(location = 0) out vec4 love_PixelColor;\n"
    "	#endif\n"
    "#else\n"
    "#ifdef LOVE_MULTI_CANVAS\n"
    "#define love_Canvases gl_FragData\n"
    "#endif\n"
    "#define love_PixelColor gl_FragColor\n"
    "#endif\n"
    "\n"
    "// See Shader::updateScreenParams in Shader.cpp.\n"
    "#define love_PixelCoord (vec2(gl_FragCoord.x, (gl_FragCoord.y * love_ScreenSize.z) + love_ScreenSize.w))\n"
    "// According to the GLSL ES 1.0 spec, uniform precision must match between stages,\n"
    "// but we can't guarantee that highp is always supported in fragment shaders...\n"
    "// We *really* don't want to use mediump for these in vertex shaders though.\n"
    "    uniform LOVE_HIGHP_OR_MEDIUMP mat4 ViewSpaceFromLocal;\n"
    "uniform LOVE_HIGHP_OR_MEDIUMP mat4 ClipSpaceFromView;\n"
    "uniform LOVE_HIGHP_OR_MEDIUMP mat4 ClipSpaceFromLocal;\n"
    "uniform LOVE_HIGHP_OR_MEDIUMP mat3 ViewNormalFromLocal;\n"
    "uniform LOVE_HIGHP_OR_MEDIUMP vec4 love_ScreenSize;\n"
    "\n"
    "// Compatibility\n"
    "#define TransformMatrix ViewSpaceFromLocal\n"
    "#define ProjectionMatrix ClipSpaceFromView\n"
    "#define TransformProjectionMatrix ClipSpaceFromLocal\n"
    "#define NormalMatrix ViewNormalFromLocal\n"
    "\n"
    "#ifdef GL_ES\n"
    "#if __VERSION__ >= 300 || defined(GL_EXT_texture_array)\n"
    "		precision lowp sampler2DArray;\n"
    "	#endif\n"
    "	#if __VERSION__ >= 300 || defined(GL_OES_texture_3D)\n"
    "		precision lowp sampler3D;\n"
    "	#endif\n"
    "	#if __VERSION__ >= 300\n"
    "		precision lowp sampler2DShadow;\n"
    "		precision lowp samplerCubeShadow;\n"
    "		precision lowp sampler2DArrayShadow;\n"
    "	#endif\n"
    "#endif\n"
    "\n"
    "#if __VERSION__ >= 130 && !defined(LOVE_GLSL1_ON_GLSL3)\n"
    "#define Texel texture\n"
    "#else\n"
    "#if __VERSION__ >= 130\n"
    "#define texture2D Texel\n"
    "		#define texture3D Texel\n"
    "		#define textureCube Texel\n"
    "		#define texture2DArray Texel\n"
    "		#define love_texture2D texture\n"
    "		#define love_texture3D texture\n"
    "		#define love_textureCube texture\n"
    "		#define love_texture2DArray texture\n"
    "#else\n"
    "#define love_texture2D texture2D\n"
    "#define love_texture3D texture3D\n"
    "#define love_textureCube textureCube\n"
    "#define love_texture2DArray texture2DArray\n"
    "#endif\n"
    "vec4 Texel(sampler2D s, vec2 c) { return love_texture2D(s, c); }\n"
    "vec4 Texel(samplerCube s, vec3 c) { return love_textureCube(s, c); }\n"
    "#if __VERSION__ > 100 || defined(GL_OES_texture_3D)\n"
    "vec4 Texel(sampler3D s, vec3 c) { return love_texture3D(s, c); }\n"
    "#endif\n"
    "#if __VERSION__ >= 130 || defined(GL_EXT_texture_array)\n"
    "vec4 Texel(sampler2DArray s, vec3 c) { return love_texture2DArray(s, c); }\n"
    "#endif\n"
    "#ifdef PIXEL\n"
    "vec4 Texel(sampler2D s, vec2 c, float b) { return love_texture2D(s, c, b); }\n"
    "vec4 Texel(samplerCube s, vec3 c, float b) { return love_textureCube(s, c, b); }\n"
    "#if __VERSION__ > 100 || defined(GL_OES_texture_3D)\n"
    "vec4 Texel(sampler3D s, vec3 c, float b) { return love_texture3D(s, c, b); }\n"
    "#endif\n"
    "#if __VERSION__ >= 130 || defined(GL_EXT_texture_array)\n"
    "vec4 Texel(sampler2DArray s, vec3 c, float b) { return love_texture2DArray(s, c, b); }\n"
    "#endif\n"
    "#endif\n"
    "#define texture love_texture\n"
    "#endif\n"
    "\n"
    "float gammaToLinearPrecise(float c) {\n"
    "  return c <= 0.04045 ? c / 12.92 : pow((c + 0.055) / 1.055, 2.4);\n"
    "}\n"
    "vec3 gammaToLinearPrecise(vec3 c) {\n"
    "  bvec3 leq = lessThanEqual(c, vec3(0.04045));\n"
    "  c.r = leq.r ? c.r / 12.92 : pow((c.r + 0.055) / 1.055, 2.4);\n"
    "  c.g = leq.g ? c.g / 12.92 : pow((c.g + 0.055) / 1.055, 2.4);\n"
    "  c.b = leq.b ? c.b / 12.92 : pow((c.b + 0.055) / 1.055, 2.4);\n"
    "  return c;\n"
    "}\n"
    "vec4 gammaToLinearPrecise(vec4 c) { return vec4(gammaToLinearPrecise(c.rgb), c.a); }\n"
    "float linearToGammaPrecise(float c) {\n"
    "  return c < 0.0031308 ? c * 12.92 : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n"
    "}\n"
    "vec3 linearToGammaPrecise(vec3 c) {\n"
    "  bvec3 lt = lessThanEqual(c, vec3(0.0031308));\n"
    "  c.r = lt.r ? c.r * 12.92 : 1.055 * pow(c.r, 1.0 / 2.4) - 0.055;\n"
    "  c.g = lt.g ? c.g * 12.92 : 1.055 * pow(c.g, 1.0 / 2.4) - 0.055;\n"
    "  c.b = lt.b ? c.b * 12.92 : 1.055 * pow(c.b, 1.0 / 2.4) - 0.055;\n"
    "  return c;\n"
    "}\n"
    "vec4 linearToGammaPrecise(vec4 c) { return vec4(linearToGammaPrecise(c.rgb), c.a); }\n"
    "\n"
    "// http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n"
    "\n"
    "mediump float gammaToLinearFast(mediump float c) { return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878); }\n"
    "mediump vec3 gammaToLinearFast(mediump vec3 c) { return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878); }\n"
    "mediump vec4 gammaToLinearFast(mediump vec4 c) { return vec4(gammaToLinearFast(c.rgb), c.a); }\n"
    "\n"
    "mediump float linearToGammaFast(mediump float c) { return max(1.055 * pow(max(c, 0.0), 0.41666666) - 0.055, 0.0); }\n"
    "mediump vec3 linearToGammaFast(mediump vec3 c) { return max(1.055 * pow(max(c, vec3(0.0)), vec3(0.41666666)) - 0.055, vec3(0.0)); }\n"
    "mediump vec4 linearToGammaFast(mediump vec4 c) { return vec4(linearToGammaFast(c.rgb), c.a); }\n"
    "\n"
    "#define gammaToLinear gammaToLinearFast\n"
    "#define linearToGamma linearToGammaFast\n"
    "\n"
    "#ifdef LOVE_GAMMA_CORRECT\n"
    "#define gammaCorrectColor gammaToLinear\n"
    "	#define unGammaCorrectColor linearToGamma\n"
    "	#define gammaCorrectColorPrecise gammaToLinearPrecise\n"
    "	#define unGammaCorrectColorPrecise linearToGammaPrecise\n"
    "	#define gammaCorrectColorFast gammaToLinearFast\n"
    "	#define unGammaCorrectColorFast linearToGammaFast\n"
    "#else\n"
    "#define gammaCorrectColor\n"
    "#define unGammaCorrectColor\n"
    "#define gammaCorrectColorPrecise\n"
    "#define unGammaCorrectColorPrecise\n"
    "#define gammaCorrectColorFast\n"
    "#define unGammaCorrectColorFast\n"
    "#endif\n"
    "uniform sampler2D love_VideoYChannel;\n"
    "uniform sampler2D love_VideoCbChannel;\n"
    "uniform sampler2D love_VideoCrChannel;\n"
    "\n"
    "vec4 VideoTexel(vec2 texcoords) {\n"
    "  vec3 yuv;\n"
    "  yuv[0] = Texel(love_VideoYChannel, texcoords).r;\n"
    "  yuv[1] = Texel(love_VideoCbChannel, texcoords).r;\n"
    "  yuv[2] = Texel(love_VideoCrChannel, texcoords).r;\n"
    "  yuv += vec3(-0.0627451017, -0.501960814, -0.501960814);\n"
    "\n"
    "  vec4 color;\n"
    "  color.r = dot(yuv, vec3(1.164,  0.000,  1.596));\n"
    "  color.g = dot(yuv, vec3(1.164, -0.391, -0.813));\n"
    "  color.b = dot(yuv, vec3(1.164,  2.018,  0.000));\n"
    "  color.a = 1.0;\n"
    "\n"
    "  return gammaCorrectColor(color);\n"
    "}\n"
    "varying LOVE_HIGHP_OR_MEDIUMP vec4 VaryingTexCoord;\n"
    "varying mediump vec4 VaryingColor;\n"
    "\n"
    "void effect();\n"
    "\n"
    "void main() {\n"
    "  effect();\n"
    "}\n"
    "#line 1\n"
    "void effect() {\n"
    "  love_PixelColor = VideoTexel(VaryingTexCoord.xy) * VaryingColor;\n"
    "}\n";

std::string arrayPixelShaderCode =
    "#version 330 core\n"
    "#define PIXEL PIXEL\n"
    "\n"
    "\n"
    "\n"
    "#if !defined(GL_ES) && __VERSION__ < 140\n"
    "#define lowp\n"
    "	#define mediump\n"
    "	#define highp\n"
    "#endif\n"
    "#if defined(VERTEX) || __VERSION__ > 100 || defined(GL_FRAGMENT_PRECISION_HIGH)\n"
    "#define LOVE_HIGHP_OR_MEDIUMP highp\n"
    "#else\n"
    "#define LOVE_HIGHP_OR_MEDIUMP mediump\n"
    "#endif\n"
    "#define number float\n"
    "#define Image sampler2D\n"
    "#define ArrayImage sampler2DArray\n"
    "#define CubeImage samplerCube\n"
    "#define VolumeImage sampler3D\n"
    "#if __VERSION__ >= 300 && !defined(LOVE_GLSL1_ON_GLSL3)\n"
    "#define DepthImage sampler2DShadow\n"
    "	#define DepthArrayImage sampler2DArrayShadow\n"
    "	#define DepthCubeImage samplerCubeShadow\n"
    "#endif\n"
    "#define extern uniform\n"
    "#ifdef GL_EXT_texture_array\n"
    "#extension GL_EXT_texture_array : enable\n"
    "#endif\n"
    "#ifdef GL_OES_texture_3D\n"
    "#extension GL_OES_texture_3D : enable\n"
    "#endif\n"
    "#ifdef GL_OES_standard_derivatives\n"
    "#extension GL_OES_standard_derivatives : enable\n"
    "#endif\n"
    "\n"
    "#ifdef GL_ES\n"
    "    precision mediump float;\n"
    "#endif\n"
    "\n"
    "#define love_MaxCanvases gl_MaxDrawBuffers\n"
    "\n"
    "#if __VERSION__ >= 130\n"
    "#define varying in\n"
    "	// Some drivers seem to make the pixel shader do more work when multiple\n"
    "	// pixel shader outputs are defined, even when only one is actually used.\n"
    "	// TODO: We should use reflection or something instead of this, to determine\n"
    "	// how many outputs are actually used in the shader code.\n"
    "	#ifdef LOVE_MULTI_CANVAS\n"
    "		layout(location = 0) out vec4 love_Canvases[love_MaxCanvases];\n"
    "		#define love_PixelColor love_Canvases[0]\n"
    "	#else\n"
    "		layout(location = 0) out vec4 love_PixelColor;\n"
    "	#endif\n"
    "#else\n"
    "#ifdef LOVE_MULTI_CANVAS\n"
    "#define love_Canvases gl_FragData\n"
    "#endif\n"
    "#define love_PixelColor gl_FragColor\n"
    "#endif\n"
    "\n"
    "// See Shader::updateScreenParams in Shader.cpp.\n"
    "#define love_PixelCoord (vec2(gl_FragCoord.x, (gl_FragCoord.y * love_ScreenSize.z) + love_ScreenSize.w))\n"
    "// According to the GLSL ES 1.0 spec, uniform precision must match between stages,\n"
    "// but we can't guarantee that highp is always supported in fragment shaders...\n"
    "// We *really* don't want to use mediump for these in vertex shaders though.\n"
    "    uniform LOVE_HIGHP_OR_MEDIUMP mat4 ViewSpaceFromLocal;\n"
    "uniform LOVE_HIGHP_OR_MEDIUMP mat4 ClipSpaceFromView;\n"
    "uniform LOVE_HIGHP_OR_MEDIUMP mat4 ClipSpaceFromLocal;\n"
    "uniform LOVE_HIGHP_OR_MEDIUMP mat3 ViewNormalFromLocal;\n"
    "uniform LOVE_HIGHP_OR_MEDIUMP vec4 love_ScreenSize;\n"
    "\n"
    "// Compatibility\n"
    "#define TransformMatrix ViewSpaceFromLocal\n"
    "#define ProjectionMatrix ClipSpaceFromView\n"
    "#define TransformProjectionMatrix ClipSpaceFromLocal\n"
    "#define NormalMatrix ViewNormalFromLocal\n"
    "\n"
    "#ifdef GL_ES\n"
    "#if __VERSION__ >= 300 || defined(GL_EXT_texture_array)\n"
    "		precision lowp sampler2DArray;\n"
    "	#endif\n"
    "	#if __VERSION__ >= 300 || defined(GL_OES_texture_3D)\n"
    "		precision lowp sampler3D;\n"
    "	#endif\n"
    "	#if __VERSION__ >= 300\n"
    "		precision lowp sampler2DShadow;\n"
    "		precision lowp samplerCubeShadow;\n"
    "		precision lowp sampler2DArrayShadow;\n"
    "	#endif\n"
    "#endif\n"
    "\n"
    "#if __VERSION__ >= 130 && !defined(LOVE_GLSL1_ON_GLSL3)\n"
    "#define Texel texture\n"
    "#else\n"
    "#if __VERSION__ >= 130\n"
    "#define texture2D Texel\n"
    "		#define texture3D Texel\n"
    "		#define textureCube Texel\n"
    "		#define texture2DArray Texel\n"
    "		#define love_texture2D texture\n"
    "		#define love_texture3D texture\n"
    "		#define love_textureCube texture\n"
    "		#define love_texture2DArray texture\n"
    "#else\n"
    "#define love_texture2D texture2D\n"
    "#define love_texture3D texture3D\n"
    "#define love_textureCube textureCube\n"
    "#define love_texture2DArray texture2DArray\n"
    "#endif\n"
    "vec4 Texel(sampler2D s, vec2 c) { return love_texture2D(s, c); }\n"
    "vec4 Texel(samplerCube s, vec3 c) { return love_textureCube(s, c); }\n"
    "#if __VERSION__ > 100 || defined(GL_OES_texture_3D)\n"
    "vec4 Texel(sampler3D s, vec3 c) { return love_texture3D(s, c); }\n"
    "#endif\n"
    "#if __VERSION__ >= 130 || defined(GL_EXT_texture_array)\n"
    "vec4 Texel(sampler2DArray s, vec3 c) { return love_texture2DArray(s, c); }\n"
    "#endif\n"
    "#ifdef PIXEL\n"
    "vec4 Texel(sampler2D s, vec2 c, float b) { return love_texture2D(s, c, b); }\n"
    "vec4 Texel(samplerCube s, vec3 c, float b) { return love_textureCube(s, c, b); }\n"
    "#if __VERSION__ > 100 || defined(GL_OES_texture_3D)\n"
    "vec4 Texel(sampler3D s, vec3 c, float b) { return love_texture3D(s, c, b); }\n"
    "#endif\n"
    "#if __VERSION__ >= 130 || defined(GL_EXT_texture_array)\n"
    "vec4 Texel(sampler2DArray s, vec3 c, float b) { return love_texture2DArray(s, c, b); }\n"
    "#endif\n"
    "#endif\n"
    "#define texture love_texture\n"
    "#endif\n"
    "\n"
    "float gammaToLinearPrecise(float c) {\n"
    "  return c <= 0.04045 ? c / 12.92 : pow((c + 0.055) / 1.055, 2.4);\n"
    "}\n"
    "vec3 gammaToLinearPrecise(vec3 c) {\n"
    "  bvec3 leq = lessThanEqual(c, vec3(0.04045));\n"
    "  c.r = leq.r ? c.r / 12.92 : pow((c.r + 0.055) / 1.055, 2.4);\n"
    "  c.g = leq.g ? c.g / 12.92 : pow((c.g + 0.055) / 1.055, 2.4);\n"
    "  c.b = leq.b ? c.b / 12.92 : pow((c.b + 0.055) / 1.055, 2.4);\n"
    "  return c;\n"
    "}\n"
    "vec4 gammaToLinearPrecise(vec4 c) { return vec4(gammaToLinearPrecise(c.rgb), c.a); }\n"
    "float linearToGammaPrecise(float c) {\n"
    "  return c < 0.0031308 ? c * 12.92 : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n"
    "}\n"
    "vec3 linearToGammaPrecise(vec3 c) {\n"
    "  bvec3 lt = lessThanEqual(c, vec3(0.0031308));\n"
    "  c.r = lt.r ? c.r * 12.92 : 1.055 * pow(c.r, 1.0 / 2.4) - 0.055;\n"
    "  c.g = lt.g ? c.g * 12.92 : 1.055 * pow(c.g, 1.0 / 2.4) - 0.055;\n"
    "  c.b = lt.b ? c.b * 12.92 : 1.055 * pow(c.b, 1.0 / 2.4) - 0.055;\n"
    "  return c;\n"
    "}\n"
    "vec4 linearToGammaPrecise(vec4 c) { return vec4(linearToGammaPrecise(c.rgb), c.a); }\n"
    "\n"
    "// http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n"
    "\n"
    "mediump float gammaToLinearFast(mediump float c) { return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878); }\n"
    "mediump vec3 gammaToLinearFast(mediump vec3 c) { return c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878); }\n"
    "mediump vec4 gammaToLinearFast(mediump vec4 c) { return vec4(gammaToLinearFast(c.rgb), c.a); }\n"
    "\n"
    "mediump float linearToGammaFast(mediump float c) { return max(1.055 * pow(max(c, 0.0), 0.41666666) - 0.055, 0.0); }\n"
    "mediump vec3 linearToGammaFast(mediump vec3 c) { return max(1.055 * pow(max(c, vec3(0.0)), vec3(0.41666666)) - 0.055, vec3(0.0)); }\n"
    "mediump vec4 linearToGammaFast(mediump vec4 c) { return vec4(linearToGammaFast(c.rgb), c.a); }\n"
    "\n"
    "#define gammaToLinear gammaToLinearFast\n"
    "#define linearToGamma linearToGammaFast\n"
    "\n"
    "#ifdef LOVE_GAMMA_CORRECT\n"
    "#define gammaCorrectColor gammaToLinear\n"
    "	#define unGammaCorrectColor linearToGamma\n"
    "	#define gammaCorrectColorPrecise gammaToLinearPrecise\n"
    "	#define unGammaCorrectColorPrecise linearToGammaPrecise\n"
    "	#define gammaCorrectColorFast gammaToLinearFast\n"
    "	#define unGammaCorrectColorFast linearToGammaFast\n"
    "#else\n"
    "#define gammaCorrectColor\n"
    "#define unGammaCorrectColor\n"
    "#define gammaCorrectColorPrecise\n"
    "#define unGammaCorrectColorPrecise\n"
    "#define gammaCorrectColorFast\n"
    "#define unGammaCorrectColorFast\n"
    "#endif\n"
    "uniform sampler2D love_VideoYChannel;\n"
    "uniform sampler2D love_VideoCbChannel;\n"
    "uniform sampler2D love_VideoCrChannel;\n"
    "\n"
    "vec4 VideoTexel(vec2 texcoords) {\n"
    "  vec3 yuv;\n"
    "  yuv[0] = Texel(love_VideoYChannel, texcoords).r;\n"
    "  yuv[1] = Texel(love_VideoCbChannel, texcoords).r;\n"
    "  yuv[2] = Texel(love_VideoCrChannel, texcoords).r;\n"
    "  yuv += vec3(-0.0627451017, -0.501960814, -0.501960814);\n"
    "\n"
    "  vec4 color;\n"
    "  color.r = dot(yuv, vec3(1.164,  0.000,  1.596));\n"
    "  color.g = dot(yuv, vec3(1.164, -0.391, -0.813));\n"
    "  color.b = dot(yuv, vec3(1.164,  2.018,  0.000));\n"
    "  color.a = 1.0;\n"
    "\n"
    "  return gammaCorrectColor(color);\n"
    "}\n"
    "varying LOVE_HIGHP_OR_MEDIUMP vec4 VaryingTexCoord;\n"
    "varying mediump vec4 VaryingColor;\n"
    "\n"
    "void effect();\n"
    "\n"
    "void main() {\n"
    "  effect();\n"
    "}\n"
    "#line 1\n"
    "uniform ArrayImage MainTex;\n"
    "void effect() {\n"
    "  love_PixelColor = Texel(MainTex, VaryingTexCoord.xyz) * VaryingColor;\n"
    "}\n";
